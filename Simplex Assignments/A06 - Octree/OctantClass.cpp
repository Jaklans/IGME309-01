#include "OctantClass.h"

using namespace Simplex;

OctantClass::OctantClass(float maxSize, vector3 center) {
	entities = std::vector<void*>();
	this->center = center;
	this->maxSize = maxSize;
}

void OctantClass::subDivide(int maxDepth, std::vector<OctantClass>* octants) {
	
	//If Octant does not have more than one entity, it does not need devided
	if (entities.size() <= 1) return;

	//Save the count for future indexing
	int index = octants->size();


	//Create subdivisions and add them to the octant list (in order for indexing)
	float newMaxSize = maxSize / 2;
	octants->push_back(OctantClass(newMaxSize, center + vector3(newMaxSize, newMaxSize, newMaxSize)));
	octants->push_back(OctantClass(newMaxSize, center + vector3(-newMaxSize, newMaxSize, newMaxSize)));
	octants->push_back(OctantClass(newMaxSize, center + vector3(newMaxSize, -newMaxSize, newMaxSize)));
	octants->push_back(OctantClass(newMaxSize, center + vector3(-newMaxSize, -newMaxSize, newMaxSize)));
	octants->push_back(OctantClass(newMaxSize, center + vector3(newMaxSize, newMaxSize, -newMaxSize)));
	octants->push_back(OctantClass(newMaxSize, center + vector3(-newMaxSize, newMaxSize, -newMaxSize)));
	octants->push_back(OctantClass(newMaxSize, center + vector3(newMaxSize, -newMaxSize, -newMaxSize)));
	octants->push_back(OctantClass(newMaxSize, center + vector3(-newMaxSize, -newMaxSize, -newMaxSize)));


	//Distribute each entity the Octant contains to its "children"
	for (int i = 0; i < entities.size(); i++) {
		//Save the max and min of the entity we are checking
		vector3* entityMax = &(reinterpret_cast<MyEntity*>(entities[i])->GetRigidBody()->GetMaxGlobal());
		vector3* entityMin = &(reinterpret_cast<MyEntity*>(entities[i])->GetRigidBody()->GetMinGlobal());

		//Store information about where to put the entity in bitset
		u_int position = 0;

		//If the entity is negative on an axis, flip the bit
		if (entityMax->x < center.x) {
			position |= 0b00000001;
		}
		if (entityMax->y < center.y) {
			position |= 0b00000010;
		}
		if (entityMax->z < center.z) {
			position |= 0b00000100;
		}

		//Check for any axis that the cube is ambiguous to
		if (entityMax->x > center.x && entityMin->x < center.x) {
			position |= 0b00001000;
		}
		if (entityMax->y > center.y && entityMin->y < center.y) {
			position |= 0b00010000;
		}
		if (entityMax->z > center.z && entityMin->z < center.z) {
			position |= 0b00100000;
		}


		//If the entity is not ambiguous to any axis
		if (!(0b00111000 & position)) {
			//Add entity to octant at index generated by position variable
			(*octants)[(int)(index + (0b00000111 & position))].entities.push_back(entities[i]);
		}
		else {
			//Start with intent to add to every subdivision
			u_int octantsToAdd =
				0b11111111;
				//01234567


			//Remove subdivisions if the entity is not ambiguous to the axis
			if (!(0b00001000 & position)) {
				if (0b00000001 & position) {
					octantsToAdd &= 0b01010101;
				}
				else {
					octantsToAdd &= 0b10101010;
				}
			}
			if (!(0b00010000 & position)) {
				if (0b00000010 & position) {
					octantsToAdd &= 0b00110011;
				}
				else {
					octantsToAdd &= 0b11001100;
				}
			}
			if (!(0b00100000 & position)) {
				if (0b00000100 & position) {
					octantsToAdd &= 0b00001111;
				}
				else {
					octantsToAdd &= 0b11110000;
				}
			}

			//Add to all octants the entity should belong to
			for (int j = 0; j < 8; j++) {
				if (0b10000000 & octantsToAdd) {
					(*octants)[index + j].entities.push_back(entities[i]);
				}
				octantsToAdd = octantsToAdd << 1;
			}
		}
	}

	//If we have not reached depth limit, subdivide each child
	if (maxDepth > 0) {

		for (int i = 0; i < 8; i++) {
			(*octants)[index + i].subDivide(maxDepth - 1, octants);
		}
	}

	//Remove all entities from this Octant (it has passed them to its "Children")
	if (entities.size() > 0) {
		entities.clear();
	}
}
void OctantClass::CheckCollisions() {
	int size = entities.size();
	for (int i = 0; i < size - 1; i++) {
		for (int j = i + 1; j < entities.size(); j++) {
			reinterpret_cast<MyEntity*>(entities[i])->IsColliding(reinterpret_cast<MyEntity*>(entities[j]));
		}
	}
}

void OctantClass::Draw(MeshManager* meshManager) {

	//Draw divisions in yellow if active, red if empty
	if (entities.size() > 1) {
		meshManager->AddWireCubeToRenderList(
			glm::scale(glm::translate(center), vector3(maxSize * 2)),
			C_YELLOW);
	}
	else {
		meshManager->AddWireCubeToRenderList(
			glm::scale(glm::translate(center), vector3(maxSize * 2)),
			C_RED);
	}
}
